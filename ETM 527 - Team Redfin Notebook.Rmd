---
title: "Portland Housing Price Prediction by Neighborhood"
Author: "Team Redfin: Wendy Lally, Cody Miller, Andrew Perigault Monte, Stephan Hoo-fatt, Jerrod Thomas"
output: html_notebook
---

##Introduction
For our team project we chose to do an analysis of real estate pricing information for Portland Oregon. Our interest is to predict how quickly the median housing price will climb within the city. We will break that into geographic regions, and try to identify any major trends from this prediction. 
Exceptional growth in urban housing prices has led to gentrification to many urban towns in recent days. With Portland being one of the most attrative cities to move to, housing prices, new development, and decades of strong urban renewal projects have culminated in housing prices soaring faster than most other American cities. 

##Business problem
In order to better understand the Portland housing market, we will be analyzing the trends in housing prices and attempt to predict the future prices of housing by neighborhood. This will provide us an indication of affordability and allow us to predict where the next bursts in housing price inflation might occur. If you are in real estate, then you should invest in these areas. If you are a city planner, you should focus your anti-gentrification and housing affordability efforts in these neighborhoods to reduce displacement in the local populations.

##Relevant data driven, analytical work in this area
The majority of our work has focused on the isolation of approriate data from our initial dataset and preparation for time series analysis. There are a number of research papers evaluating this particular topic of affordability in metropolitan areas and some specifically in Portland. [Oregon Live is hosting an interactive map on this topic](https://projects.oregonlive.com/maps/gentrification/), showcasing similar results to those that we are seeking to understand: what neighborhoods are under pressure from gentrification and which are likely to be next. 

##Data Source, Data Exploration, Descriptive Statistics, Variable Selection
Our data was sourced from the Redfin Data Center. The dataset was quite large and we initially reviewed the 47 variables for validity with our analysis in mind. We ultimately limited this to 13 variables, seven related to cost and availability which could be used for our preditinos. Another three variables related to the time series, and three related to the regions were selected to allow us to do appropriate filtering of our dataset from a nationwide, nearly 1.5 gigabyte CSV into a more manageable, Oregon-only dataset. 

As part of our data cleaning, we realized that the dataset periods offered were 90 day time slices, so we decided to select periods of January-March, April-June, July-September, and October-December in order to avoid overlapping data sets. It does appears that Redfin's analysis of this data used each 90-day average to represent the month in which the period ended. This causes some overlapping but also results in smoother data and more data points. If we ultimately decide that four data points per year is too few, we may consider re-factoring our data segmentation in a similar way.

##Methodologies Considered
With the project selection, we are limited to time series-based modeling. We initially used the linear trend time series modeling technique and compared this to the naive approach. We are also considering caomparing the accuracy of these two models to a model involving trend and seasonality if there is time.

##Next Steps
* Run time series model on training and validation sets
* Try various time series models and compare accuracy
    + Trend and seasonality
    + Linear, and polynomial 
    + Naive
* Compare accuracy between these models
* Create comparison array to evaluate neighborhood predictions
* Continue building report and narrative
* Investigate possibility of visualizing with a mapping tool
* Beautify graphs/visualizations

##References
[Redfin Data Center: Downloadable Housing Market Data From Redfin](https://www.redfin.com/blog/data-center)

[Gentrification and Displacement Study: implementing an equitable inclusive development strategy in the context of gentrification](https://www.portlandoregon.gov/bps/article/454027)
```{r}
#Load library and suppress warnings
suppressWarnings(suppressMessages(library(dplyr)))

# load all redfin data into the data frame
Oregon.df <- read.csv("Redfin Data Portland_ All Residential_filtered.csv")

#Select and summarize only the home variables
selected.var <-c(2, 6, 9, 24, 27, 30, 39)
Home_data.df = Oregon.df[, selected.var]
print("Relavent Housing variables summary")
summary(Home_data.df)

#Select and summarize only the time variables 
selected.var <-c(33, 34, 35)
Time_data.df = Oregon.df[, selected.var]
print("Relavent Time variables summary")
summary(Time_data.df)

#Select and summarize only the time variables 
selected.var <-c(40, 41, 45)
Time_data.df = Oregon.df[, selected.var]
print("Relavent Location variables summary")
summary(Time_data.df)
```
##Neighborhood Time Series Graphs
```{r}
# filter to just neighborhood records - the full set has by zipcode, and other breakdowns we don't care about
neighborhoods.df <- Oregon.df[Oregon.df$Region.Type == "neighborhood",]
```

```{r}
# filter out the last two years to make training data. Doesn't work yet, working on syntax.\
# binary errors - Will evaluate when time 
# neighborhoods.df <- neighborhoods.df[strptime(neighborhoods.df$Period.Begin, format="%m/%d/%Y") < strptime('1/Jan/2016:00:01:00',format='%d/%b/%Y:%H:%M:%S'),]

# load the training data list of unique neighborhoods into an array for iteration
 neighborhoods.array <- unique(neighborhoods.df$Region, incomparables = FALSE)
```


```{r}
# Create a storage array for our results
neighborhoodsSummary.array <- array()

#We want to store: neighborhood name, timeseries
neighborhoodsSummary.array <- c("")
```

```{r}
#loop through all the neighboorhoods and for each create a timeseries and print the plot
for (neighborhood in neighborhoods.array){
# use if just want to look at one neighborhood: for (neighborhood in c("Portland, OR - Rose City Park")){
  #select a neighborhood into a dataframe
  oneNeighborhood.df <- neighborhoods.df[Oregon.df$Region == neighborhood,]
  
  #filter out the observations for months that aren't January (1), April (4), July (7), October (10). 
  #Note that had to invert, so selected ones that did not have these patterns matched.
  oneNeighborhood.df<-oneNeighborhood.df[grep("2/|3/|5/|6/|8/|9/|11/|12/", oneNeighborhood.df$Period.Begin, invert = TRUE),]
  # somehow they are out of order, now to sort the period.begin
  oneNeighborhood.df <- oneNeighborhood.df[order(as.Date(oneNeighborhood.df$Period.Begin, format="%m/%d/%Y")),]
  dat1 <- oneNeighborhood.df # save for debugging prior to removing columns
  
  #log how many rows each neighborhood has available
  cat(neighborhood, " has ", nrow(oneNeighborhood.df), " rows. \n")
  
  # select the median price column for the timeseries
  oneNeighborhood.df <- oneNeighborhood.df[c(18)]
  
  # create the timeseries
  oneNeighborhood.timeseries <- ts(oneNeighborhood.df, frequency=4, start=c(2012,1))
  # plot and set title to the appropriate heading
  plot(oneNeighborhood.timeseries, main=neighborhood)
}


```


```{r}
# This section only applies to 1 neighboorhood - ALL neighboorhoods are below
# Should probally be deprecated, once we submit, this section is for practice

# Load required library
library(forecast)

# Naive Approach
# H = Number of periods for forecasting
plot(naive(oneNeighborhood.timeseries, h = 8))
plot(naive(oneNeighborhood.timeseries, h = 4))

# Seasonal Naive Method 
plot(snaive(oneNeighborhood.timeseries, h = 8))
plot(snaive(oneNeighborhood.timeseries, h = 4))

# Drift Method Method 
plot(rwf(oneNeighborhood.timeseries, h = 8, drift = T))
plot(rwf(oneNeighborhood.timeseries, h = 4, drift = T))

# Holt Winters Method 
plot(forecast(HoltWinters(oneNeighborhood.timeseries), h = 8))
plot(forecast(HoltWinters(oneNeighborhood.timeseries), h = 4))


```

```{r}
# Naive Forecast 
# 8 Period Forecast & 4 Period Forecast

#loop through all the neighboorhoods and for each create a timeseries and print the plot
for (neighborhood in neighborhoods.array){
# use if just want to look at one neighborhood: for (neighborhood in c("Portland, OR - Rose City Park")){
  #select a neighborhood into a dataframe
  oneNeighborhood.df <- neighborhoods.df[Oregon.df$Region == neighborhood,]
  
  #filter out the observations for months that aren't January (1), April (4), July (7), October (10). 
  #Note that had to invert, so selected ones that did not have these patterns matched.
  oneNeighborhood.df<-oneNeighborhood.df[grep("2/|3/|5/|6/|8/|9/|11/|12/", oneNeighborhood.df$Period.Begin, invert = TRUE),]
  # somehow they are out of order, now to sort the period.begin
  oneNeighborhood.df <- oneNeighborhood.df[order(as.Date(oneNeighborhood.df$Period.Begin, format="%m/%d/%Y")),]
  dat1 <- oneNeighborhood.df # save for debugging prior to removing columns
  
  #log how many rows each neighborhood has available
  cat(neighborhood, " has ", nrow(oneNeighborhood.df), " rows. \n")
  
  # select the median price column for the timeseries
  oneNeighborhood.df <- oneNeighborhood.df[c(18)]
  
  # create the timeseries
  oneNeighborhood.timeseries <- ts(oneNeighborhood.df, frequency=4, start=c(2012,1))
  
  # Apply Forecasting Method to timeseries - Naive Method
  # 8 Periods
  plot(naive(oneNeighborhood.timeseries, h = 8))
  
  # 4 Periods
  plot(naive(oneNeighborhood.timeseries, h = 4))
  
}
```
```{r}
# Seasonal Naive Forecast 
# 8 Period Forecast & 4 Period Forecast

library(forecast)

#loop through all the neighboorhoods and for each create a timeseries and print the plot
for (neighborhood in neighborhoods.array){
# use if just want to look at one neighborhood: for (neighborhood in c("Portland, OR - Rose City Park")){
  #select a neighborhood into a dataframe
  oneNeighborhood.df <- neighborhoods.df[Oregon.df$Region == neighborhood,]
  
  #filter out the observations for months that aren't January (1), April (4), July (7), October (10). 
  #Note that had to invert, so selected ones that did not have these patterns matched.
  oneNeighborhood.df<-oneNeighborhood.df[grep("2/|3/|5/|6/|8/|9/|11/|12/", oneNeighborhood.df$Period.Begin, invert = TRUE),]
  # somehow they are out of order, now to sort the period.begin
  oneNeighborhood.df <- oneNeighborhood.df[order(as.Date(oneNeighborhood.df$Period.Begin, format="%m/%d/%Y")),]
  dat1 <- oneNeighborhood.df # save for debugging prior to removing columns
  
  #log how many rows each neighborhood has available
  cat(neighborhood, " has ", nrow(oneNeighborhood.df), " rows. \n")
  
  # select the median price column for the timeseries
  oneNeighborhood.df <- oneNeighborhood.df[c(18)]
  
  # create the timeseries
  oneNeighborhood.timeseries <- ts(oneNeighborhood.df, frequency=4, start=c(2012,1))
  
  # Apply Forecasting Method to timeseries - Seasonal Naive Method
  # 8 Periods
  plot(snaive(oneNeighborhood.timeseries, h = 8))
  
  # 4 Periods
  plot(snaive(oneNeighborhood.timeseries, h = 4))
  
}
```

```{r}
# Drift Method
# 8 Period Forecast & 4 Period Forecast

library(forecast)

#loop through all the neighboorhoods and for each create a timeseries and print the plot
for (neighborhood in neighborhoods.array){
# use if just want to look at one neighborhood: for (neighborhood in c("Portland, OR - Rose City Park")){
  #select a neighborhood into a dataframe
  oneNeighborhood.df <- neighborhoods.df[Oregon.df$Region == neighborhood,]
  
  #filter out the observations for months that aren't January (1), April (4), July (7), October (10). 
  #Note that had to invert, so selected ones that did not have these patterns matched.
  oneNeighborhood.df<-oneNeighborhood.df[grep("2/|3/|5/|6/|8/|9/|11/|12/", oneNeighborhood.df$Period.Begin, invert = TRUE),]
  # somehow they are out of order, now to sort the period.begin
  oneNeighborhood.df <- oneNeighborhood.df[order(as.Date(oneNeighborhood.df$Period.Begin, format="%m/%d/%Y")),]
  dat1 <- oneNeighborhood.df # save for debugging prior to removing columns
  
  #log how many rows each neighborhood has available
  cat(neighborhood, " has ", nrow(oneNeighborhood.df), " rows. \n")
  
  # select the median price column for the timeseries
  oneNeighborhood.df <- oneNeighborhood.df[c(18)]
  
  # create the timeseries
  oneNeighborhood.timeseries <- ts(oneNeighborhood.df, frequency=4, start=c(2012,1))
  
  # Apply Forecasting Method to timeseries - Drift Method
  # 8 Periods
  plot(rwf(oneNeighborhood.timeseries, h = 8, drift = T))
  
  # 4 Periods
  plot(rwf(oneNeighborhood.timeseries, h = 4, drift = T))
  
}

```

```{r}
# Holt Winters Forecast Method
# 8 Period Forecast & 4 Period Forecast

library(forecast)

#loop through all the neighboorhoods and for each create a timeseries and print the plot
for (neighborhood in neighborhoods.array){
# use if just want to look at one neighborhood: for (neighborhood in c("Portland, OR - Rose City Park")){
  #select a neighborhood into a dataframe
  oneNeighborhood.df <- neighborhoods.df[Oregon.df$Region == neighborhood,]
  
  #filter out the observations for months that aren't January (1), April (4), July (7), October (10). 
  #Note that had to invert, so selected ones that did not have these patterns matched.
  oneNeighborhood.df<-oneNeighborhood.df[grep("2/|3/|5/|6/|8/|9/|11/|12/", oneNeighborhood.df$Period.Begin, invert = TRUE),]
  # somehow they are out of order, now to sort the period.begin
  oneNeighborhood.df <- oneNeighborhood.df[order(as.Date(oneNeighborhood.df$Period.Begin, format="%m/%d/%Y")),]
  dat1 <- oneNeighborhood.df # save for debugging prior to removing columns
  
  #log how many rows each neighborhood has available
  cat(neighborhood, " has ", nrow(oneNeighborhood.df), " rows. \n")
  
  # select the median price column for the timeseries
  oneNeighborhood.df <- oneNeighborhood.df[c(18)]
  
  # create the timeseries
  oneNeighborhood.timeseries <- ts(oneNeighborhood.df, frequency=4, start=c(2012,1))
  
  # Apply Forecasting Method to timeseries - Holt Winters Method
  # 8 Periods
  plot(forecast(HoltWinters(oneNeighborhood.timeseries), h = 8))
  
  # 4 Periods
  plot(forecast(HoltWinters(oneNeighborhood.timeseries), h = 4))
  
}
```

